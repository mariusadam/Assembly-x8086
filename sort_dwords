;3. Se da un sir de dublucuvinte. Sa se ordoneze crescator sirul 
;cuvintelor superioare ale acestor dublucuvinte. Cuvintele inferioare raman neschimbate.
;Ex: dandu-se: sir DD 12AB5678h 1256ABCDh, 12344344h 
;rezultatul va fi 12345678h 1256ABCDh, 12AB4344h.
assume cs: code, ds: data
data segment
	sir dd 12AB5678h, 1256ABCDh, 12344344h, 10106666h, 10002222h, 999AAAAh
	l equ ($ - sir) / 4
	rez dd dup(?)
	ordonat db ?
data ends

code segment
start:
	mov ax, data
	mov ds, ax							;incarc in ds adresa segmentului de date
	mov cx, l -1
	mov si, 2
	cld									;parcurgerea se face de la inceput la sfarsit
	sort:
		mov cx, l - 1
		mov ordonat, -1					;presupunem sirul ordonat
		mov si, 2
		compara:
			mov ax, word ptr sir[si]	;ax = sir[si]		;trec cu si la urmatorul cuvant
			mov bx, word ptr sir[si + 4];bx = sir[si + 4]
			cmp ax, bx					;ax ? bx 
			jna next					;daca sir[si] <= sir[si + 4]  trec la pasul urmator, altfel le interschimb in memorie
			mov ordonat, 0				;daca am ajuns aici inseamna ca sirul nu este ordonat
			mov word ptr sir[si], bx 	;de unde am luat valoarea ce se afla in ax pun valoarea din bx 
			mov word ptr sir[si + 4], ax;de unde am luat valoarea ce se afla in bx pun valoarea din ax 
			next:
			add si, 4					;trec la urmatorul element
		loop compara
 		cmp ordonat, 0					;daca am gasit un element care nu se afla pe pozitia corecta, mai parcurge odata sirul
	je sort		
	mov cx, l * 2
	mov si, 0
	copy:
		mov ax, word ptr sir[si]
		mov word ptr rez[si], ax
		add si, 2
	loop copy
	mov ax, 4C00h						;incheierea executiei programului
	int 21h
code ends
end start
